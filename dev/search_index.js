var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = ProconIO","category":"page"},{"location":"#ProconIO","page":"Home","title":"ProconIO","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Inspired by proconio-rs, I wrote this package to handle inputs for competitive programming contests.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [ProconIO]","category":"page"},{"location":"#ProconIO.@input-Tuple{Any}","page":"Home","title":"ProconIO.@input","text":"The usage is similar to proconio-rs. You need to specify the variable name and its structure.\n\n@input a = Int\n\nMultiple variables need to be nested in a block.\n\n@input begin\n    a = Char\n    b = Float32\n    c = (Int, Char)\n    d = String\n    e = Bool\nend\n\nArrays need to be specified in the form of [type; shape].\n\n@input begin\n    a = [Int; 3]\n    b = [Float32; (2, 3)]\nend\n\nComplex structures can also be handled.\n\n@input a = [(Int, [Int; (2, 2)], Char); (2, 2)]\n\nIn CP, the size of arrays is usually specified by the input itself. This can be handled by using variables already read in.\n\nNote that ProconIO.jl follows Julia's column-major convention, instead of the row-major which is commonly used in CP. So you may need to swap the row and column indices when reading the array.\n\n@input begin\n    n = Int\n    m = Int\n    v = [Int; (m, n)]\nend\n\nIf you prefer a row-major flavor, you can use a vector of vectors instead.\n\n@input begin\n    n = Int\n    m = Int\n    v = [[Int; m]; n]\nend\n\nSometimes the input is a vector of variable-length vectors. This can be handled by leaving out the shape and reading it from the input instead. The following code reads in a vector of n variable-length vectors.\n\n@input begin\n    n = Int\n    v = [[Int; ]; n]\nend\n\n```\n\n\n\n\n\n","category":"macro"}]
}
